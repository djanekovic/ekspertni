\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[croatian]{babel}
\usepackage{placeins}
\usepackage{mathptmx}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{siunitx}
\usepackage{graphicx}
\usepackage[sorting=none]{biblatex}
%\addbibresource{literatura.bib}

\begin{document}

\begin{titlepage}
	\centering
	{\scshape\LARGE Sveučilište u Zagrebu\par}
	\vspace{0.5cm}
	{\scshape\Large Fakultet elektrotehnike i računarstva\par}
    \vfill
	{\Large\itshape Projekt kolegija Ekspertni sustavi \par}
	\vspace{0.5cm}
	{\huge\bfseries Rješavanje i analiza rješavanja igrice Minesweeper\par}
	\vspace{0.5cm}
	{\Large\itshape Darko Janeković, Jelena Nemčić \par}
	\vfill
	{\large Zagreb, 2020.}
\end{titlepage}

\section{Uvod}

Minesweeper je igra za jednog igrača koja se sastoji od ploče dimenzija $X x Y$. Neka od polja ploče sadrže skrivene mine, a igračev cilj je locirati sve mine i otvoriti sva preostala polja.

Igraču je u svakom trenutku igre poznato koliko je mina još na ploči. U svakom svom potezu igrač može:
\begin{itemize}
    \item označiti polje kao da se tamo nalazi mina,
    \item maknuti oznaku mine s prethodno označenog polja,
    \item otvoriti polje.
\end{itemize} 

Označavanjem polja kao mine smanjuje se broj preostalih mina neovisno o tome nalazi li se stvarno mina na tom polju. Ukoliko je polje označeno kao mina nije ga moguće otvoriti bez da se prethodno makne oznaka da se tamo
nalazi mina. Takva akcija označavanja je korisna ukoliko igrač sa sigurnošću zna da se na nekom polju
nalazi mina. S druge strane, igrač može otvoriti polje oko kojeg se ne nalazi niti jedna
mina, polje oko kojeg se nalazi $n$ mina te konačno polje na kojem se nalazi mina.

Otvaranje polja oko kojeg se ne nalazi niti jedna mina nastavit će rekurzivno otvarati susjedna
polja sve dok se ne otvori neko polje koje u susjedstvu ima minu. Otvaranje polja oko kojeg
se nalazi $n$ mina ispisat će na ploču brojku $n$. Igrač je izgubio ako je otvorio polje s minom, dok otvaranje zadnjeg polja koje nije mina
označava pobjedu.

U okviru ovog projekta bit će analizirane dvije taktike za rješavanje igrice Minesweeper pri čemu obje
taktike svode problem na programiranje s ograničenjima (engl. \textit{Constraint Programming}),
ali se postupak rješavanja razlikuje.

U prvom slučaju problem će se rješavati simpleks metodom, dok će se u drugom slučaju isti
problem rješavati i tretirati kao problem zadovoljivosti (engl. \textit{Satisfaction Problem}).
Prednosti i nedostatci oba načina rješavanja bit će komentirani u nastavku.

\section{Modeliranje problema}

Moguće je pretpostaviti, bez gubitka općenitosti, da je ploča dimenzija $3 \times 3$ te da je
svaka vrijednost na ploči $m_{i, j} \in \{\bot, \top\}$. Ukoliko je vrijednost pojedinog polja
$\top$ tamo se nalazi mina, odnosno ako je vrijednost $\bot$ na tom se polju ne nalazi mina.
Skup $\mathcal{N}(m_{i, j})$ definira susjedstvo polja $m_{i, j}$, a s $n$ će biti označavan broj mina
u susjednim poljima polja $m_{i, j}$, pri čemu se gledaju sva polja koja su mu susjedna horizontalno, vertikalno i dijagonalno.

Nakon otvaranja polja $m_{i, j}$ agent u bazu znanja upisuje:
\begin{equation}
    \sum_{a \in \mathcal{N}(m_{i, j})} a = n
    \label{eq:1}
\end{equation}

\subsection{Zaključivanje}
Zaključivanje korištenjem ranije definiranih pravila bit će objašnjeno u nastavku. Stanje
svijeta prikazano je tablicom:

\begin{table}[ht]
    \centering
    \begin{tabular}{llll}
                           & 1                      & 2                      & 3                      \\ \cline{2-4}
    \multicolumn{1}{l|}{1} & \multicolumn{1}{l|}{}  & \multicolumn{1}{l|}{}  & \multicolumn{1}{l|}{}  \\ \cline{2-4}
    \multicolumn{1}{l|}{2} & \multicolumn{1}{l|}{1} & \multicolumn{1}{l|}{1} & \multicolumn{1}{l|}{1} \\ \cline{2-4}
    \multicolumn{1}{l|}{3} & \multicolumn{1}{l|}{0} & \multicolumn{1}{l|}{0} & \multicolumn{1}{l|}{0}  \\ \cline{2-4}
    \end{tabular}
\end{table}

\begin{align*}
    m_{1, 1} + m_{1, 2} = 1 \\
    m_{1, 1} + m_{1, 2} + m_{1, 3} = 1 \\
    m_{1, 2} + m_{1, 3} = 1 \\
\end{align*}

Iz čega se lako može zaključiti da vrijedi $m_{1, 1} = \bot$, $m_{1, 2} = \top$ i
$m_{1, 3} = \bot$. Drugim riječima jedina mina nalazi se na polju $m_{1, 2}$.

S druge strane, zaključivanja mogu biti nejednoznačna. Primjer stanja svijeta koji nije
jednoznačno rješiv nalazi se u tablici u nastavku:
\begin{table}[ht]
    \centering
    \begin{tabular}{llll}
                           & 1                      & 2                     & 3                     \\ \cline{2-4}
    \multicolumn{1}{l|}{1} & \multicolumn{1}{l|}{}  & \multicolumn{1}{l|}{} & \multicolumn{1}{l|}{} \\ \cline{2-4}
    \multicolumn{1}{l|}{2} & \multicolumn{1}{l|}{}  & \multicolumn{1}{l|}{} & \multicolumn{1}{l|}{} \\ \cline{2-4}
    \multicolumn{1}{l|}{3} & \multicolumn{1}{l|}{1} & \multicolumn{1}{l|}{} & \multicolumn{1}{l|}{} \\ \cline{2-4}
    \end{tabular}
\end{table}

\begin{equation*}
    m_{2, 1} + m_{2, 2} + m_{3, 2} = 1
\end{equation*}

S obzirom da agentu nije poznata nikakva druga informacija, agent na temelju ovog sustava ne
može ništa zaključiti i mora pogađati.

\subsubsection{Zaključivanje rješavanjem SAT problema}
Prvi korak u zaključivanju rješavanjem SAT problema jest svođenje
problema na oblik konjugirane normalne forme (eng. \textit{conjunctive normal form}), u nastavku CNF.

Gledajući prethodni primjer rješivog stanja svijeta izvodimo za njega klauzule. 
S obzirom na to da se oko polja $m_{2, 1}$ nalazi jedna mina, jedno od susjednih polja $m_{1,1}$ i $m_{1, 2}$ mora sadržavati minu. Isto tako, točno jedno od susjednih polja ne smije biti mina. Postavljamo klauzule:
\begin{equation*}
    (m_{1, 1} \vee m_{1, 2}) \wedge (\neg m_{1, 1} \vee \neg m_{1, 2})
\end{equation*}
Prva klauzula bit će zadovoljena ako
je barem jedan susjed mina, a druga klauzula ako barem jedno polje nije mina.

Slično razmišljanje kao i ranije moguće je primijeniti i za ostala polja:
\begin{gather*}
    (m_{1, 1} \vee m_{1, 2} \vee m_{1, 3}) \wedge
        (\neg m_{1, 1} \vee \neg m_{1, 2}) \wedge
        (\neg m_{1, 2} \vee \neg m_{1, 3}) \wedge
        (\neg m_{1, 3} \vee \neg m_{1, 1}) \\
    (m_{1, 2} \vee m_{1, 3}) \wedge (\neg m_{1, 2} \vee \neg m_{1, 3})
\end{gather*}

Jednom kad je baza znanja predstavljena u CNF obliku, zaključivanje se izvodi teoremom dedukcije.
Primjerice, potrebno je zaključiti da se na polju $m_{1, 2}$ nalazi mina. Baza znanja $\Gamma$
proširuje se s $\neg m_{1, 2}$ te je potrebno pokazati da je $(\Gamma \wedge \neg m_{1, 2})$
nezadovoljiva. Ukoliko je formula nezadovoljiva, agent može biti siguran da se tamo nalazi mina te proširiti
bazu znanja s tom informacijom kao i označiti to polje kao opasno.

Na isti način, budući da je $(\Gamma \wedge m_{1, 1})$ nezadovoljiva formula, agent može biti siguran da se na tom polju ne nalazi mina i otvoriti ga. 


\subsubsection{Zaključivanje simpleks metodom}
Simpleks algoritam je metoda rješavanja problema u linearnom programiranju. Ovaj postupak može se
tumačiti i kao pohlepna inačica SAT postupka.

Ulaz u algoritam je niz jednadžbi i nejednadžbi i ciljna funkcija koju je potrebno minimizirati ili maksimizirani tako da su sve jednadžbe i nejednadžbe zadovoljene. U našem slučaju svi ulazi su jednadžbe budući da uvijek točno znamo koliko je mina u susjedstvu nekog polja. Također umjesto jedne ciljne funkcije imamo ograničenja da svaka varijabla može poprimiti samo vrijednosti 0 ili 1. Cilj nam je pronaći odgovarajuće vrijednosti svih varijabli tako da je sustav zadovoljiv. 

Jednadžbe se postavljaju kao u formuli \ref{eq:1}, odnosno za svako otvoreno polje piše se jednadžba koja nam govori da suma svih njegovih susjeda mora biti jednaka broju susjednih mina. Za primjer s početka poglavlja dobivamo jednadžbe:
\begin{gather*}
\label{csp}
    m_{1, 1} + m_{1, 2} = 1 \\
    m_{1, 1} + m_{1, 2}+ m_{1, 3} = 1 \\
    m_{1, 2} + m_{1, 3} = 1
\end{gather*}

Sustav u simpleks metodi uvijek mora biti zadovoljiv, ako nije onda postoji greška u samoj ploči ili u zadavanju jednadžbi. Međutim, može se dogoditi da sustav u određenom trenutku nije jednoznačno zadovoljiv jer nam još nisu poznate sve informacije s ploče.

Ovaj algoritam za razlučivanje ne ponaša se kao SAT postupak i to je očekivano. Glavna razlika
između dva algoritma vidi se ukoliko algoritam nije siguran nalazi li se na nekom polju
mina. SAT algoritam će tada pretpostaviti da se mina tamo nalazi i nikada neće otvoriti polje za koje ne može sa sigurnošću reći da nije mina. S druge strane, simpleks metoda takva polja dodaje u skup dostupnih polja te iz njega slučajnim odabirom odabire polje koje će otvoriti, što može biti i polje gdje se zapravo nalazi mina. Iz ovog razloga je SAT puno bolji algoritam za rješavanje
ovog problema. Međutim, prednost simpleks algoritma nad SAT algoritmom je u vremenskoj složenosti.

\section{Implementacija}

Program se sastoji od ploče, koja komunicira s grafičkim sučeljem i mijenja stanje igre, te od dvije strategije: \textit{CSP} odnosno simpleks metoda i \textit{SAT} aključivanje.
Obje strategije naslijeđuju apstraktan razred \textit{Strategy} te sadrže metode za otvaranje polja, dohvaćanje slučajno odabranog polja, stvaranje ograničenja te metodu za izvršavanje sljedećeg koraka u rješavanju.

\subsection{SAT zaključivanje}

Za implementaciju SAT zaključivanja korištena je biblioteka \textit{pysat} i unutar nje algoritam \textit{minicard}.  

\subsection{Simpleks metoda}

Kako bi se problem riješio linearnim programiranjem, korištena je biblioteka \textit{Cassowary} i \textit{SimplexSolver}. 

U ovoj strategiji svako polje prikazano je instancom razreda \textit{Variable} kako bi ih \textit{SimplexSolver} mogao obraditi i postavljati njihove vrijednosti.

Na samom početku izvođenja dodaje se ograničenje za svako polje, koje govori da vijednost tog polja mora biti između 0 i 1. Budući da \textit{SimplexSolver} radi samo sa cijelim brojevima, time smo ograničili vrijednosti polja na 0 i 1.

Dalje se u svakom sljedećem koraku generiraju ograničenja za svako novootvoreno polje kao što je opisano u \ref{csp}. \textit{SimplexSolver} automatski uzima u obzir sva dotadašnja ograničenja i mijenja vrijednosti varijabli kako bi sva bila zadovoljena. Sva polja čija je vrijednost postavljena na 1 označavaju se kao mine. Za sva polja koja nisu označena s 1 smatra se da ne sadrže minu te se dodaju u skup polja za otvaranje. Na kraju se uzima slučajnim odabirom jedno polje iz tog skupa ili, ako je skup prazan, jedno slučajno odabarano polje iz cijele ploče. Odabrano polje se otvara, kao i susjedna ako niti jedno od njih ne sadrži minu, i korak strategije završava.

\section{Zaključak}
\end{document}